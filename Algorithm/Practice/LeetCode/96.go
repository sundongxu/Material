package LeetCode

/**
 * 96. Unique Binary Search Trees
 * 描述：
 * 难度：Medium
 * 类型：DP
 */
// 动态规划
// 假设f(i)表示由数1～n能构成的二叉搜索树数量
// 假设F(i,n)表示以数i为根节点，由数1～n能构成的二叉搜索树数量
// 根据分析，以数i为根节点时，其左子树只能由比它小的数1～i-1构成，一共有f(i-1)种可能，其右子树只能由比它大的数i+1~n构成，一共有f(n-(i+1)+1)=f(n-i)种可能构成
// 故可推导出: F(i,n) = f(i-1) * f(n-1) - 推导式1
// 而f(i)本质上就是分别由数1～n中的任意一个数作为根节点时的可能构成情况数量的总和，即f(i) = F(1,i) + F(2,i) + ... + F(i,i) - 推导式2
// 结合上述推导式1
// 则状态转移方程为: f(i) = f(0)*f(i-1) + f(1)*f(i-2) + ... + f(i-1)*f(0)
// 显然，f(0)=1, f(1)=1, f(2)=f(0)*f(1) + f(1)*f(0) = 1 + 1 = 2, f(3) = f(0)*f(2) + f(1)*f(1) + f(2)*f(0) = 1*2 + 1*1 + 2*1 = 5，以此类推
func numTrees(n int) int {
	dp := make([]int, n+1)
	dp[0], dp[1] = 1, 1
	for i := 2; i <= n; i++ {
		for j := 0; j < i; j++ {
			dp[i] += dp[j] * dp[i-1-j]
		}
	}
	return dp[n]
}
