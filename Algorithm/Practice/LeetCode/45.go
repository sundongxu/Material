package LeetCode

import "math"

/**
 * 45. Jump Game II
 * 描述：
 * 难度：Medium
 * 类型：DP & Greedy
 */
// 假定一定能到最后一级，如何在跳跃次数最少的情况下实现？
// 存在一种遍历/穷举所有可能空间的解题思路，贪心或动态规划
// 如果用贪心，那么并不是每一步能跳多远就跳多远，或者说并不需要找出一个具体的跳跃方案，而是找出每一步的最远跳跃范围
// 如果这个范围达到或超过了最后一个元素，那么此时跳跃次数一定是最少的
// 每次都在上次能跳到的范围（end）内(<=end)选择一个能跳的最远的位置（也就是能跳到maxPosition位置的点）作为下次的起跳点
func jump(nums []int) int {
	// nums = [2,3,1,2,4,2,3]
	end := 0                           // 上次跳跃可达范围右边界（下次的最右起跳点）
	maxPosition := 0                   // 目前能跳到的最远位置
	steps := 0                         // 已跳跃次数
	for i := 0; i < len(nums)-1; i++ { // i < len(nums)-1这个条件非常重要
		if end >= len(nums)-1 {
			// 如果上次跳跃的右边界已达到或超过最后一个位置，说明已经不需要再跳了，直接结束
			break
		}
		// 右边界还没达到最后一个位置，那么仍需要更多次的跳跃，至少需要再跳跃一次
		maxPosition = max(maxPosition, i+nums[i]) // 不断尝试最大化本次跳跃所能跳至的最远位置，可能会达到或超过最后一个位置，但这次跳跃必须计数
		if i == end {
			// 到达上次跳跃所能到达的右边界了，完成本次跳跃，推进右边界同时递增跳跃次数
			end = maxPosition // 更新end，将maxPosition作为下次的起跳点
			steps++           // 完成本次跳跃的计数，准备进行下一次跳跃
		}
	}
	return steps
}

// 动态规划，根据题目假设：一定能够跳到最后一级，以及55题的推论：如果能跳到最后一级，那么一定可以跳到任意一级
// 假设f[i]表示，到达第i个位置时，所用的最小跳跃次数，初始化时需要将所有元素置为MAX_INT，或>len(nums)，且f[0]=0
// 要想到达第i个位置，假设从第j(j<i)个位置起跳，那么存在两种情况：到得了和到不了，显然只需要考虑到得了情况，应该排除从它起跳到不了第i个位置的j
// 状态状态方程为：f[i] = min(f[i], f[j]+1)，其中j代表所有从位置j起跳能够到达位置i的位置下标的集合，且0<=j<i
// 最终就只要看最后一级台阶对应的f[len(nums)-1]的值，根据状态f[i]的定义，它的值直接就是到达最后一级台阶所用的最小跳跃次数
// 动态规划的核心，就是用前面已经算好的状态，根据合适的状态转移方程，推导当前的状态
// 有点类似于数学归纳法的思想，只要前面计算过程正确，状态转移方程也正确，那么推导出来的当前状态也一定正确
func jump2(nums []int) int {
	// nums = [2,3,1,2,4,2,3]
	dp := make([]int, len(nums))
	dp[0] = 0
	for i := 0; i < len(nums); i++ {
		dp[i] = math.MaxInt
		for j := 0; j < i; j++ {
			if j+nums[j] >= i {
				// 从位置j起跳，能够到达位置i，此时需要根据状态转移方程重新计算dp[i]
				dp[i] = min(dp[i], dp[j]+1)
			}
		}
	}
	return dp[len(nums)-1]
}

func min(a, b int) int {
	if a <= b {
		return a
	}
	return b
}
